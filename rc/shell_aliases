#!/bin/sh
# If not running interactively, don't do anything
[[ $- != *i* ]] && return

ROOT_PATH=""
[ -d "/data/data/com.termux" ] && ROOT_PATH="/data/data/com.termux/files"

ROOT_PROC="${ROOT_PATH}/proc"
ROOT_USR="${ROOT_PATH}/usr"
ROOT_USR_BIN="${ROOT_USR}/bin"

alias sh="${SHELL}"
alias sudo='sudo '
alias lsmnt='lsblk -l | tail -n +2 | awk '\''length($7) { print $1" => "$7 }'\'''
alias grep='grep -a --color --text'
alias pcregrep='pcregrep -a --color --text'
alias uptime='uptime -p && printf "since " && uptime -s'

# Directory navigation
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias .....='cd ../../../..'
alias ......='cd ../../../../..'
alias cd..='cd ..'
alias cd...='cd ../..'
alias cd....='cd ../../..'
alias cd.....='cd ../../../..'
alias cd......='cd ../../../../..'
alias cd="OLDPWD2=\${OLDPWD} && cd"
alias cd-="cd -"
alias cd--="__destDir=\${OLDPWD2} && cd \${__destDir}"

IS_SSH=false
if [ -n "${SSH_CLIENT}" ] || [ -n "${SSH_TTY}" ]; then
    IS_SSH=true
fi

if [ ! -f "/bin/busybox" ]; then
    COREUTILS_VERSION=$(ls --version | head -n 1 | awk '{print $4}' | awk -F. '{print $1}')
fi

${IS_SSH} && alias poweroff="echo Surely you don\'t mean to do that on the remote machine! && echo If you do, use \'command poweroff\' instead."

if ${IS_SSH} || [[ -f "/bin/busybox" ]] || [[ ${COREUTILS_VERSION} -lt 9 ]]; then
    alias ls='ls --color=auto -h -Q'
else
    alias ls='ls --color=auto -h -Q --hyperlink=always'
fi

[ ! -f "${ROOT_USR_BIN}/sl" ] && alias sl=ls

[ -f "${ROOT_USR_BIN}/systemctl" ]  && alias systemctl='systemctl --no-pager -l -n20'
[ -f "${ROOT_USR_BIN}/xterm" ]      && alias xterm='xterm -rv'
[ -f "${ROOT_USR_BIN}/xprop" ]      && alias xprop-wmclass='xprop | grep "WM_CLASS"'
[ -f "${ROOT_USR_BIN}/wget" ]       && alias wget-persistent='wget -c --retry-connrefused --waitretry=1 --read-timeout=10 --timeout=5 -t 0'
[ -f "${ROOT_PROC}/acpi/bbswitch" ] && alias bbswitch-status="awk '{print $2}' /proc/acpi/bbswitch"

[ -f "${ROOT_USR_BIN}/alsi" ]        && [ ! -f "${ROOT_USR_BIN}/neofetch" ]   && alias neofetch='alsi'
[ -f "${ROOT_USR_BIN}/neofetch" ]    && [ ! -f "${ROOT_USR_BIN}/alsi" ]       && alias alsi='neofetch'

if [ -f "${ROOT_USR_BIN}/git" ]; then
    alias git="git --no-pager"
    alias git-push="git fetch && git push"
    alias git-pull="git fetch && git pull --rebase"
    alias git-commit="git fetch && __gitCommit"
fi

if [ -f "${ROOT_USR_BIN}/tmux" ]; then
    alias tmux-new='tmux new -s'
    alias tmux-resume='tmux attach-session -t'
    alias tmux-list='tmux list-session'
fi

if [ ! -f "${ROOT_USR_BIN}/hostname" ]; then
    if [ -f "${ROOT_USR_BIN}/hostnamectl" ]; then
        alias hostname='hostnamectl hostname'
    else
        alias hostname="cat ${ROOT_ETC}/hostname"
    fi
fi

if [ "${OSTYPE}" = "cygwin" ]; then
    alias killall="taskkill /IM"
fi

### Package manager
local PACKAGE_MANAGER_CMD='sudo printf "" && ${PACKAGE_MANAGER}'
local CAN_PM_ALIAS_AUTOCOMPLETE=false

if [[ "${PACKAGE_MANAGER}" == "paru" ]]; then
    PACKAGE_MANAGER_CMD="${PACKAGE_MANAGER_CMD} --noredownload --norebuild --sudoloop" # Optimisations
    #PACKAGE_MANAGER_CMD="${PACKAGE_MANAGER_CMD} --nouseask --noprovides --skipreview" # Prompt skip
    PACKAGE_MANAGER_CMD="${PACKAGE_MANAGER_CMD} --noconfirm" # Prompt skip
    PACKAGE_MANAGER_CMD="${PACKAGE_MANAGER_CMD} --bottomup --color auto" # Visuals
elif [[ "${PACKAGE_MANAGER}" == "yaourt" ]]; then
    PACKAGE_MANAGER_CMD="${PACKAGE_MANAGER_CMD} --noconfirm"
fi

for COMPLETION_SOURCE in "/usr/share/bash-completion/completions/${PACKAGE_MANAGER}.bash" \
                         "/usr/share/bash-completion/completions/${PACKAGE_MANAGER}"; do
    if [ -f "${COMPLETION_SOURCE}" ]; then
        CAN_PM_ALIAS_AUTOCOMPLETE=true
        source "${COMPLETION_SOURCE}"
        break
    fi
done

alias yeet="${PACKAGE_MANAGER_CMD}"
${CAN_PM_ALIAS_AUTOCOMPLETE} && complete -F _${PACKAGE_MANAGER} yeet

### Fixes
[ -f "${ROOT_USR_BIN}/monodevelop" ]   &&  alias monodevelop="GNOME_DESKTOP_SESSION_ID="" monodevelop"
[ -f "${ROOT_USR_BIN}/dotnet" ]        &&  alias dotnet='TERM=xterm dotnet'
